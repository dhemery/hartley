package com.dhemery.core;

import org.hamcrest.Matcher;

import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * A lazy stream over the objects supplied by an iterable source.
 * The stream iterates over the items in the order they are delivered by the source.
 * The stream iterates over the items as late as possible.
 * @param <T> the type of object supplied by the stream
 */
public class LazyStream<T> {
    private final Iterator<T> source;

    private LazyStream(Iterator<T> source) {
        this.source = source;
    }

    /**
     * Create a lazy stream over the items supplied by the iterable source.
     */
    public LazyStream(Iterable<T> items) {
        this(items == null ? Collections.<T>emptySet().iterator() : items.iterator());
    }

    /**
     * Return a stream of the source items that satisfy the criteria.
     */
    public LazyStream<T> filter(Matcher<? super T> criteria) {
        return lazyStreamOf(filteringIterator(criteria));
    }

    /**
     * Perform the action on each source item.
     */
    public void forEach(Action<? super T> action) {
        if(action == null) return;
        while(source.hasNext()) action.actOn(source.next());
    }

    /**
     * Append each source item onto the given destination.
     * Items are appended in the order they are deliverd by this stream's source.
     * @param destination the destination to which to append the items.
     * @return {@code destination}
     */
    public <C extends Collection<? super T>> C into(C destination) {
        while(source.hasNext()) destination.add(source.next());
        return destination;
    }

    /**
     * Return a stream of values generated by applying the given function to each source item.
     */
    public <F> LazyStream<F> map(Feature<? super T, F> function) {
        return lazyStreamOf(mappingIterator(function));
    }

    private static <S> LazyStream<S> lazyStreamOf(Iterator<S> source) {
        return new LazyStream<S>(source);
    }

    private <F> MappingIterator<T,F> mappingIterator(Feature<? super T, F> function) {
        return new MappingIterator(source, function);
    }

    private FilteringIterator<T> filteringIterator(Matcher<? super T> criteria) {
        return new FilteringIterator(source, criteria);
    }

    static class FilteringIterator<T> implements Iterator<T> {
        private final Iterator<T> source;
        private final Matcher<? super T> criteria;
        private T next;

        public FilteringIterator(Iterator<T> source, Matcher<? super T> criteria) {
            this.source = source;
            this.criteria = criteria;
            next = nextMatchingItem();
        }

        @Override
        public boolean hasNext() {
            return next != null;
        }

        @Override
        public T next() {
            if(!hasNext()) throw new NoSuchElementException();
            T current = next;
            next = nextMatchingItem();
            return current;
        }

        @Override
        public void remove() {
            source.remove();
        }

        private T nextMatchingItem() {
            while(source.hasNext()) {
                T candidate = source.next();
                if(criteria.matches(candidate)) return candidate;
            }
            return null;
        }
    }

    static class MappingIterator<T, F> implements Iterator<F> {
        private final Iterator<T> source;
        private final Feature<? super T, F> function;

        public MappingIterator(Iterator<T> source, Feature<? super T, F> function) {
            this.source = source;
            this.function = function;
        }

        @Override
        public boolean hasNext() {
            return source.hasNext();
        }

        @Override
        public F next() {
            return function.of(source.next());
        }

        @Override public void remove() {
            source.remove();
        }
    }
}
